<head>
<meta charset="utf-8">
<style>

body {
  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;
  margin: auto;
  position: relative;
  width: 960px;
}

xxform {
  position: absolute;
  right: 10px;
  top: 10px;
}

.node {
  border: solid 1px white;
  font: 10px sans-serif;
  line-height: 12px;
  overflow: hidden;
  position: absolute;
  text-indent: 2px;
}

#console {
  display:block;
}

#output
{
  border-style: solid;
  border-width: 1pt;
  font-size: 9pt;
  overflow-y:auto; 
  height:50em;
}

#output td 
{
  font-size: 9pt;
}
</style>

<link rel="stylesheet" href="http://code.jquery.com/ui/1.11.3/themes/smoothness/jquery-ui.css">

<script src="http://code.jquery.com/jquery-1.10.2.js"></script>
<script src="http://code.jquery.com/ui/1.11.3/jquery-ui.js"></script>
<script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>

<script type="text/javascript" src="https://www.google.com/jsapi"></script>
 <script type="text/javascript">
    google.charts.load("current", {packages:["corechart"]});

    function drawBarChart(dataTable, extra_options)
    {
      var data = google.visualization.arrayToDataTable(dataTable);
      var patterns = extra_options.patterns;
      var view = new google.visualization.DataView(data);
      var cols = [];
      var r0 = dataTable[0];
      var displayPatterns = patterns.join(" vs. ");
      var title = "Distribution of " + displayPatterns + " over " + extra_options.grouping + "";

      for (var i=0; i < r0.length; i++)
      {
        cols.push(i);
      } 
      
      view.setColumns(cols);

//      view.setColumns([0, 1,
//                       { calc: "stringify",
//                         sourceColumn: 1,
//                         type: "string",
//                         role: "annotation" }]);

      var options = {
        title: title,
        width: 1000,
        height: 30*dataTable.length,
        isStacked: true,
        bar: { groupWidth: "95%"},
        chartArea: {left: 400} ,
        legend: { position: "none" },
      };
     
      if (extra_options != null)
      { 
        $.each(extra_options, function(k,v)
        {
          options[k] = v;
        });
      };
      if (r0.length < 3)
      {
        options['isStacked'] = false;
      }
      var chart;
      if (options['orientation'] == 'vertical')
      {
         chart = new google.visualization.ColumnChart(document.getElementById("barchart_values"));
      } else
      {
         chart = new google.visualization.BarChart(document.getElementById("barchart_values"));
      }

    function selectHandler() 
    {
      var selectedItem = chart.getSelection()[0];
      if (selectedItem) 
      {
        var value = data.getValue(selectedItem.row, selectedItem.column);
        var rowLabel = data.getValue(selectedItem.row, 0);
        var patt = patterns[selectedItem.column-1];
        log('User selected an item with value' + value);
        log ('rowLabel: ' + rowLabel);
        log ('searchPattern: ' + patterns[selectedItem.column-1]); 
        log ('grouping: '  + options.grouping);
        var searchData = makeSearchPatternAndFilter(options.grouping, rowLabel, patt); 
        log(JSON.stringify(searchData));
        performSearch(searchData.patt, searchData.filter);
      }
    }

    google.visualization.events.addListener(chart, 'select', selectHandler);

    chart.draw(view, options);
  }
  </script>


<script src="//d3js.org/d3.v3.min.js"></script>

<script>

var treemap;
var color;
var margin;
var div;

// maps metadata spec to subcorpus size

var subCorpusSize = {};
var subCorporaComputed = {};
var normalizeToSize = 1000000;
var prepared = false;

function prepareTree()
{
   margin = {top: 40, right: 10, bottom: 10, left: 10},
   width = 960 - margin.left - margin.right,
   height = 500 - margin.top - margin.bottom;

   color = d3.scale.category20c();
   // color = function(x) { return 'red'; };
   treemap = d3.layout.treemap()
    .size([width, height])
    .sticky(true)
    .value(function(d) { return d.size; });

   document.getElementById('treemapdiv').innerHTML = "";

   div = d3.select("#treemapdiv").append("div")
    .style("position", "relative")
    .style("width", (width + margin.left + margin.right) + "px")
    .style("height", (height + margin.top + margin.bottom) + "px")
    .style("left", margin.left + "px")
    .style("top", margin.top + "px");

  // alert("div:" + div);

  prepared = true;
}

function showTree(root)
{
   prepareTree();
   var node = div.datum(root).selectAll(".node")
      .data(treemap.nodes)
    .enter().append("div")
      .attr("class", "node")
      .call(position)
      .style("background", function(d) { return d.children ? color(d.name) : null; })
      .text(function(d) { return d.children ? null : d.name + ":" + d.size; });

  // alert(JSON.stringify(node));
  d3.selectAll("input").on("change", function change() {
    var value = this.value === "count"
        ? function() { return 1; }
        : function(d) { return d.size; };

    node
        .data(treemap.value(value).nodes)
      .transition()
        .duration(1500)
        .call(position);
  }); 
}


function position() {
  this.style("left", function(d) { return d.x + "px"; })
      .style("top", function(d) { return d.y + "px"; })
      .style("width", function(d) { return Math.max(0, d.dx - 1) + "px"; })
      .style("height", function(d) { return Math.max(0, d.dy - 1) + "px"; });
}

</script>

<script type="text/JavaScript">

var BASE_URL =  location.protocol + "//" + location.hostname + ":" + location.port + "/blacklab-server/zeebrieven/"

//alert(BASE_URL);


var groupSizes = '';


function sort_groups_by_first_column(A)
{
  function compare(a,b) {
    if (a[0] < b[0])
      return -1;
    else if (a[0] > b[0])
      return 1;
    else 
      return 0;
  };

  A.sort(compare);
}

// Show an array of hits in a table
function showHits(hits, docs, pattern, filter) {

    // Context of the hit is passed in arrays, per property
    // (word/lemma/PoS). Right now we only want to display the 
    // words. This is how we join the word array to a string.
    function words(context) {
        return context['word'].join(" ");
    }

    // Iterate over the hits.
    // We'll add elements to the html array and join it later to produce our
    // final HTML.
    var html = [
       "<h4>Concordances for <tt>" + pattern + "</tt> with filter <tt>" + filter +  "</tt></h4>",
       "<table><tr><th>Title</th><th>Keyword in context</th></tr>"];
    $.each(hits, function (index, hit) {

        // Add the document title and the hit information
        var doc = docs[hit['docPid']];
        html.push("<tr><td><i>" + doc['title'] + "</i></td><td>" + words(hit['left']) +
            " <b>" + words(hit['match']) + "</b> " + words(hit['right']) + 
            "</td></tr>");
    });
    html.push("</table>");
    output(html.join("\n")); // Join lines and append to output area
}

// Main program: performs a search and shows the results
function performSearch(patt, filter) {

    // Clear the output area

    clear();
    
    // Carry out the request and call the showHits function
    $.ajax({
        url: BASE_URL + "hits",
        jsonp: "jsonp",
        dataType: "jsonp",
        data: {
            patt: patt,
            number: 200,
            filter: filter
        },
        success: function (response) {
            // Got results. Show the hits, along with the document titles.
            //alert(response);
            showHits(response['hits'], response['docInfos'], patt, filter);
        },
        error: function(xhr, statusText) { alert( 'error:' + statusText); }
    });
}

function makeSearchPatternAndFilter(grouping, rowLabel, patt)
{
  // alert(grouping + ":" + (typeof grouping));

  var criteria = grouping.split(/\s*,\s*/);
  var filters = rowLabel.split(/\s*\/\s*/);
  
  var filterParts = []; 

  for (var i=0; i < criteria.length; i++)
  {
    var c = criteria[i];
    var f = filters[i];
 
    if (c.indexOf('century:') > -1)
    {
      var yearFrom = 100 * (f-1);
      var yearTo = (100 * f) -1;
      f = '[' + yearFrom +  " TO " + yearTo + ']';
      c = c.replace('century:', 'field:');
    } else
    {
      f = '"' + f +  '"';
    }
    c = c.replace('field:', '');
    var filterPart = c + ':' + f;
    log('part ' + i +  '=' + filterPart);
    filterParts.push(filterPart);
  } ;
  var searchData =
  { 
     patt: patt,
     filter: filterParts.join(' AND ')
  };
  return searchData;
}

function hasUnknown(x)
{
  return (x.indexOf('empty') > -1 || x.indexOf('unknown') > -1);
}
function barChartGroups(response, options)
{
  var my_table = []; // [["group", "size"]];
  $.each(response.hitGroups, function(index,hitGroup)
  {
    var display = hitGroup.identityDisplay;
    if (display=='')  display='empty';
    if (!hasUnknown(display))
      my_table.push([display, hitGroup.size]);
  });
  sort_groups_by_first_column(my_table);
  my_table.unshift(["group","size"]);

  options.patterns = [response.queryData.patt];
  options.grouping = response.queryData.group;

  drawBarChart(my_table, options);
  createTree(response);
}

function barChartTwoPatterns(response1, response2, options)
{
  //log('calling two pattern barchart...?');
  var h1 = {};
  var h2 = {};
  var h = {};     
  var my_table = [];

  $.each(response1.hitGroups, function(index,hitGroup)
  {
    var display = hitGroup.identityDisplay;
    if (display=='')  display='empty';
    if (!hasUnknown(display))
    {
      h1[display] = hitGroup.size;
      h[display] = hitGroup.size;
      h2[display] = 0;
    }
  });

  $.each(response2.hitGroups, function(index,hitGroup)
  {
    var display = hitGroup.identityDisplay;
    if (display=='')  display='empty';
    if (!hasUnknown(display))
    {
      h2[display] = hitGroup.size;
      //log(display + '->' + hitGroup.size);
      if (typeof h[display] == 'undefined') 
      {
        h[display] = 0;
        h1[display] = 0;
      }
      h[display] += hitGroup.size;
    }
  });
  $.each(h, function(k,v)
  {
    my_table.push([k,h1[k], h2[k]]);
  });
  sort_groups_by_first_column(my_table);
  my_table.unshift(["group", "h1", "h2"]);
  log(JSON.stringify(my_table));
  options.patterns = [response1.queryData.patt, response2.queryData.patt] ;
  options.grouping = response1.queryData.group;
  drawBarChart(my_table, options);
  createTree(response1); // not right.... // should do this differenly for 2...
}

function createTree(response)
{
  var myTree = {"name":"root", "size":0};

  // response moet gesorteerd worden...

  function findChild(node,label)
  {
    var c = node.children;
    var udef;
    if (typeof c == "undefined")
    {
      return udef;
    } else
    {
      for (var i=0; i < c.length; i++)
      {
        var ch = c[i];
        if (ch.name == label)
        {
          return ch;
        }
      }
      return udef;
    }
  } 

  function insertNode(path, node, size)
  {
    var display = "";
    for (var i=0; i < path.length; i++)
    {
      var label = path[i];
      label = label.replace(/str: */,"");
      label = label.replace(/\$CM/, ",");

      if (label == '')
       label='_EMPTY_';

      display += label;

      if (i < path.length-1)
      {
        display += "/";
      } 

      
      node["size"] += size;

      var next = findChild(node,display);
      
      if (typeof next != "undefined")
      {
        node = next;
      } else
      {
        var c = node.children;
        if (typeof c == "undefined")
        {
          c = node.children = [];
        }
        var newNode = {"name" : display, "size": size};
        c.push(newNode);
        node = newNode;
      }
    }
  }

  var my_table = []; // [["group", "size"]];
  $.each(response.hitGroups, function(index,hitGroup)
  {
    var display = hitGroup.identity;
    if (display=='')  display='empty';
    my_table.push([display, hitGroup.size]);
  });

  sort_groups_by_first_column(my_table);

   $.each(my_table, function(index,row)
   {
     var breakdown = row[0].split(/, */);
     var size = row[1];
     insertNode(breakdown, myTree, size);
   });

//  $.each(response.hitGroups, function(index,hitGroup)
//  {
//    var breakdown = hitGroup.identity.split(/, */);
//    var size = hitGroup.size;
//    insertNode(breakdown, myTree, size); 
//  });
 
  var treeTxt = JSON.stringify(myTree);
  treeTxt = treeTxt.replace(/},/g, "},\n"); 
  //log(treeTxt);
  showTree(myTree);
}

function toCentury(id)
{
  function f(str,p1,p2)
  {
    return Number(p1)+1;
  };
  var idNew = id.replace(/([0-9]{2})([0-9]{2})/,f); 
  return idNew;
}

function reGroupOneItem(grouping,item)
{
  var idNew = grouping.fi(item.identity);
  var displayNew = grouping.fd(item.identityDisplay);
  item.identity = idNew;
  item.identityDisplay = displayNew;
}

function reGroupItems(grouping,response)
{
  var h = {};
  var h1 = {};
  $.each(response.hitGroups, function(index,item)
  {
    reGroupOneItem(grouping,item);
    if (typeof h[item.identity] == 'undefined')
    {
      h[item.identity] = item.size;
    } else
    {
      h[item.identity] += item.size;
    }
  });
  var hitGroupsNew = [];
  $.each(response.hitGroups, function(index,item)
  {
    var id = item.identity;
    if (typeof h1[id] == 'undefined')
    {
      item.size = h[item.identity];
      hitGroupsNew.push(item);
      h1[item.identity] = 'kiekeboe';
    }
  });
  response.hitGroups = hitGroupsNew;
  log('reworked hitGroups: ' + JSON.stringify(response.hitGroups));
}


function performSearchWithGrouping(patt, group, filter, callback, normalized, options)
{

    // horrible regrouping stuff
    var group_org = group;
    if (group.indexOf('century:') > -1)
    {
       var grp = group.replace(/century:/,"field:");
       var f = function(x) { return toCentury(x); };
       var newGroup = {grouping: grp, fi: function(x) {return f(x);}, fd:f};
       group = newGroup;
       log("group:" + JSON.stringify(group));
    }
    var regrouping = false;
    var grouping;

    if (group instanceof Object)
    {
      regrouping = true;
      grouping = group;
      log('group' + JSON.stringify(group) + ':' + group.fi('1718'));
      group = group['grouping'];
    }   
  
    if (normalized) // better: check first whether retrieval is necessary
    {
       if (typeof subCorporaComputed[group] == 'undefined')
       {
         getSubcorpusSizes(patt, group, filter, callback, options); 
         return;
       }
    } // nee, synchronisatie klopt niet zo....

    // performSearch(patt, "");

    log('single Search:' + patt + ' Filter=' + filter);

    // Carry out the request and call the showHits function

     var queryData_org = 
     {
            patt: patt,
            group: group_org,
            filter: filter,
            number: 1000
     };
    $.ajax({
        url: BASE_URL + "hits",
        jsonp: "jsonp",
        dataType: "jsonp",
        data: {
            patt: patt,
            group: group,
            filter: filter,
            number: 1000
        },
        success: function (response) 
        {
            // alert('Ok');

            response.queryData = queryData_org; // HM. zit er vast al op een andere manier in....		

            if (regrouping)
            {
              reGroupItems(grouping,response);
            }	

            if (normalized) // normalized subcorpus sizes
            {
               $.each(response.hitGroups, function(index,item)
               {
                  item.size = (normalizeToSize * item.size) / subCorpusSize[item.identity];
               });
            };
            callback(response, options); 
        },
        error: function(xhr, statusText) { alert( 'error:' + statusText); }
    });
}


function performSearchesWithGrouping(patt1, patt2, group, filter, callback0, chart_options)
{

  log('P1:' + patt1);
  log('P2:' + patt2);

  var response1;
  var response2;
  var callback2;

  var callback1 = function(response)
  {
     //log('callback1');
     response1=response;
     //log("R1:" + JSON.stringify(response1));
     performSearchWithGrouping(patt2,group,filter, callback2, false, chart_options);
  };

  callback2 = function (response)
  {
    //log('callback2');
    response2 = response;
    //log("R2:" + JSON.stringify(response2));
    callback0(response1,response2,chart_options);
  };

  log('start searching for: ' +  patt1);

  performSearchWithGrouping(patt1, group, filter, callback1, false, chart_options);
}

// Clear output area
function clear() {
    $('#output').html('');
}

// Add HTML to the output area
function output(addHtml) {
    $('#output').append(addHtml).append("\n");
}

function log(txt)
{
   $('#console').append(txt).append("\n");
}

function getSubcorpusSizes(patt, grouping, filter, callback1, options)
{
  log('get Subcorpus sizes!...');
  function callback(response)
  {
     $.each(response.hitGroups, function(index,item)
     {
       subCorpusSize[item.identity] = item.size;
     });
     subCorporaComputed[grouping] = 'true';
     performSearchWithGrouping(patt,grouping, filter, callback1, true, options);
  }
  performSearchWithGrouping('[]', grouping, "", callback, false, null);
}

function subCorpus()
{
  var group = document.forms["searchForm"].elements["group"].value;

  var normalized = document.forms["searchForm"].elements["normalize"].checked;

  var options = {};

  options["isStacked"] = document.forms["searchForm"].elements["isStacked"].value;
  options["orientation"] = document.forms["searchForm"].elements["orientation"].value;

  performSearchWithGrouping("[]",group, "", barChartGroups, normalized, options);
}


function doSubmit()
{
  clear();
  var pattern = document.forms["searchForm"].elements["pattern"].value;
  var pattern1 = document.forms["searchForm"].elements["pattern1"].value;
  var filter = document.forms["searchForm"].elements["filter"].value;
  var group = document.forms["searchForm"].elements["group"].value;

  
  var normalized = document.forms["searchForm"].elements["normalize"].checked;
  log('normalized: '  + normalized);

  var options = {};

  options["isStacked"] = document.forms["searchForm"].elements["isStacked"].value;
  options["orientation"] = document.forms["searchForm"].elements["orientation"].value;

  //alert(pattern);

  if (pattern1 == '')
  {
    performSearchWithGrouping(pattern,group, filter, barChartGroups, normalized, options);
  }
  else
    performSearchesWithGrouping(pattern, pattern1, group, filter, barChartTwoPatterns, options);
  return false;
}
</script>
</head>
<body>
<form style='display:none'>
  <label><input type="radio" name="mode" value="size" checked> Size</label>
  <label><input type="radio" name="mode" value="count"> Count</label>
</form>

<form name="searchForm" id='searchForm' onsubmit="return false">
<table>
<tr valign='top'>
<td>
Search pattern 
<td> <textarea rows='3' cols='80' name='pattern'>[lemma=".*cht.*|.*kopen.*" & word=".*ft.*" & lemma != ".* ft.*"]</textarea><br>
</tr>


<tr valign='top'>
<td>
Contrasting search pattern (optional)
<td> <textarea rows='3' cols='80' name='pattern1'>[lemma=".*cht.*|.*kopen.*" & word=".*cht.*" & lemma != ".* ft.*"]</textarea><br>
</tr>

<tr valign='top'>
<td>
Filter 
<td>
<textarea rows='3' cols='80' name='filter'></textarea><br>
</tr>

<tr valign='top'>
<td>
Grouping criteria 
<td>
<input size='100' type='text' name='group' value='field:regiocode'><br>
</tr>
</table>

<h4>Chart options</h4>
Stack: none <input checked='checked' type="radio" name="isStacked" value='false'>
|
Stack: absolute <input checked='checked' type="radio" name="isStacked" value='true'>
|
Stack: relative <input type="radio" name="isStacked" value='relative'>
<br>
Column chart (vertical bars) <input type='radio' name='orientation' value='horizontal'>
Bar chart (horizontal bars) <input type='radio' checked='checked' name='orientation' value='vertical'> <br>
Normalize frequencies <input type='checkbox'  name='normalize'>
</form>

<button onclick="return doSubmit()">Search</button>
<button onclick="return subCorpus()">Show subcorpus sizes</button>

<div id="barchart_values" style="width: 900px;"></div>
<hr>
<div id='output'></div>
<hr>
<div id="treemapdiv"></div>
<hr>
<pre id='console' style='color:white;background-color:black; overflow-y:auto; height:50em'></pre>
